## 网络

### TCP/IP

#### TCP

SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码)
Acknowledge number(确认号码)
TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。

TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。

TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。

在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。

一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。

当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。

一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。

序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。

1. 三次握手过程

> 1. 客户端向服务端 SYN bit=1 seq = X
> 2. 服务端向客户端 SYN bit=1 seq = Y ACK bit=1 ACK num=x+1
> 3. 客户端向服务端 ACK bit =1 ACK num = Y+1

2. 半连接状态 半关闭 半打开

> 发生在TCP三次握手中,如果A向B发起连接,B也正常情况下响应了,但是A不继续三次握手,使得服务器端阻塞在SYN_RECV状态,这就是半连接
> 半关闭对应TCP四次挥手的FIN_WAIT_2状态
> 半打开 如果一方异常关闭(断网,断电) 而另一方并不知情.处于半打开状态,若不进行通信则无法发现问题,可以引入心跳机制,检测到了发送RST重新建立连接

3. SYN洪范攻击

> 当TCP三次握手进行完前两次后,服务端处于半连接状态,会分配TCB(Transmission Control Block),当开放一个TCP端口后,该端口就会处于listening状态,不停的监听该端口的syn报文,一旦接收到客户端发来的syn报文,就需要为该请求分配一个TCB,通常TCB至少需要280个字节,在某些操作系统中,TCB需要1300个字节,并返回一个SYN  ACK命令,立刻转为SYN-RECEIVED即半开连接状态.如果恶意的向某个端口发送大量的SYN包,则可以试服务器打开大量的半开连接,系统会为此耗尽资源
>
> 防范措施:
> 1. 无效连接的释放
>> 监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。
> 2. 延缓TCB分配方法
>> Syn Cache技术
>>
>> 系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。
>
>> Syn Cookie技术
>>
>> Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。
>
>> 使用SYN Proxy防火墙
>>
>> 防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c', 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。
>
>> 连接队列
> > 在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。
> > ![](https://pic2.zhimg.com/80/v2-c4688fba5db30b31c913f549108c9735_720w.jpg)
> > 对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。
> > 查看是否有连接溢出
> > netstat -s | grep LISTEN

- 四次挥手过程

> 1.客户端向服务端 FIN bit=1 seq = X
> 2.服务端向客户端 ACK bit=1 ACK num = X+1
> 3.服务端向客户端 FIN bit=1 seq = Y
> 4.客户端向服务端 ACK bit=1 ACK num = Y+1
> ![](https://pic3.zhimg.com/80/v2-629f51f6f535ebd7683f944707b21d1e_720w.jpg)

1. 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

> 关闭连接时 收到对方的FIN报文时,仅仅表示对方不再发送数据了,但是还可以接收数据,己方是否现在关闭发送数据通道,需要上层应用决定,因此己方的ACK和FIN一般会分开发送(服务端先发ACK再发FIN)
> 建立连接时 服务端在LISTEN状态下,收到建立连接请求的SYN报文后,把ACK和SYN放在一个报文里发送给客户端.

2. 四次挥手中间状态的变化对应的缓冲队列

3. 为什么四次挥手释放连接时需要等待2MSL

> MSL就是maximun segment lifetime(最大分节生命期) 这是一个IP数据包能在互联网上生存的最长时间,超过这个时间将在网络中小时.MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒，因而，TIME_WAIT状态一般维持在1-4分钟。

4. time_wait状态的作用

> 1.可靠的实现TCP全双工连接的终止
> 在进行四次挥手过程中,最后的ACK是由主动关闭端发出的 如果这个ACK丢失,服务器会重发FIN,因此客户端必须维护状态信息,允许它重发最终的ACK.如果不维持这个状态信息,那么客户端将响应RST分节,服务器将此分节解释为一个错误.因此,要实现TCP全双工连接的正常终止,必须处理终止序列四个分节任何一个分节的丢失情况,主动关闭的客户端必须维持状态信息进入TIME_WAIT状态
> 2.允许老的重复分节在网络中消逝
> TCP分节可能由于路由器异常而"迷途",在迷途期间,TCP发送端可能因确认超时而重发这个分节,迷途的节点在路由器修复后也会被送往目的地,这个原来的迷途分节就被称为lost duplicate.在关闭TCP连接后,如果马上建立起一个相同的ip:port之间的TCP连接,后一个连接被称为前一个连接的化身.前一个的连接的迷途重复分组在前一个连接终止之后出现,从而被误解成属于新的连接.为了避免这个情况,TCP不允许处于TIME_WAIT状态的连接启动一个新的化身,因为TIME_WAIT状态持续2MSL,就可以确保成功建立一个TCP连接的时候,来自连接先前化身的重复分组已经在网络中消逝.




> 如果两端同时发出关闭请求结果如何(交叉挥手)

- 拥塞控制

> 滑动窗口

> 慢启动

> 快恢复

> 快速重传

> 超时重传

> 什么是粘包如何避免粘包

- UDP

> TCP与UDP之间的区别

- DNS

> DNS的具体过程

> DNS是基于UDP实现的协议

- HTTP/HTTPS

> keepalive

> HTTP状态码

> HTTP和HTTPS的区别

> HTTPS的连接过程

> https具体ssl怎么加密

> http的包的结构具体什么样

> 安全证书的签发与验证

> 输入一个url会发生什么，从应用层说到数据链路层，然后往上走

- socket通信

- 正反向代理

- 描述请求一个网页的整个过程越详细越好

### 操作系统

- 并发模型

> 什么是进程

> 进程间通信

> 简述一下进程的切换过程

> 僵尸进程

> 孤儿进程

- 什么是线程

> 线程间通信

> 简述一下线程的切换过程

> 同一进程中不同线程共享和独享的资源分别有哪些

> 进程与线程的区别

- 死锁

> 死锁产生的条件
>> 资源互斥
>
>> 请求保持
>
>> 循环等待
>
>> 非抢占

- 解决死锁的办法

> 调度算法
>> 先到先服务
>
>> 最短耗时优先
>
>> 时间片轮转
>
>> 多级反馈队列
>
>> 最大最小公平算法

- 虚拟存储

1. 内核态和用户态的区别

2. 进程线程间切换，还有内核态和用户态切换

3. 协程了解吗

4. 进程线程区别

### 数据结构

- 如何用栈实现队列

1. 容器扩容问题，底层结构问题

### 数据库

1. 数据库索引优缺点